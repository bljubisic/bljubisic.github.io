<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Explorations</title><description>An explorations with Swift and other tech</description><link>https://bljubisic.github.io</link><language>en</language><lastBuildDate>Thu, 21 Aug 2025 14:56:50 +0200</lastBuildDate><pubDate>Thu, 21 Aug 2025 14:56:50 +0200</pubDate><ttl>250</ttl><atom:link href="https://bljubisic.github.io/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://bljubisic.github.io/posts/VisionPro%20-%20Develop%20an%20Immersive%20Game</guid><title>Chasing Colors - Developing an Immersive Game</title><description>Chasing Colors - Developing an Immersive Game</description><link>https://bljubisic.github.io/posts/VisionPro%20-%20Develop%20an%20Immersive%20Game</link><pubDate>Thu, 21 Aug 2025 14:51:00 +0200</pubDate><content:encoded><![CDATA[<h1>Chasing Colors - Developing an Immersive Game</h1><p>When the challenge of creating an immersive game for Apple Vision Pro came up, I was excited to explore the possibilities of this new platform. The goal was to create a game that would not only be visually stunning but also engaging and interactive, leveraging the unique capabilities of the Vision Pro. I have already did a SwiftUI update for QuickToDo app, so I was familiar with the platform. The game, titled "Chasing Colors", is a simple yet captivating experience where players chase and collect colored orbs in a vibrant 3D environment. The game is intentionally designed to be simple, focusing on the immersive experience rather than complex mechanics. The main purpose of this app is to showcase the capabilities of the Vision Pro and provide a fun, engaging experience for users. I wanted to try out how to use RealityView and RealityKit to create a 3D environment that players can explore and interact with. Also, I wanted to experiment with Attachments and Anchors to create a more immersive experience.</p><h2>Game Overview</h2><p>First thing that user see is difficulty selection screen, where user can choose between three different difficulties: Easy, Medium, and Hard. Each difficulty level changes the initial number of orbs in the game, with Easy starting with 10 orbs, Medium with 20, and Hard with 30. The game is designed to be played in an unobtrusive environment, allowing players to focus on the immersive experience without distractions. The gameplay is simple: player should 'tap' on the orbs to collect them, selecting only the orbs with specified color. Remaining time is displayed on the attachment screen and the level is completed when all orbs with specified color are collected, or time runs out. There are three major levels within the game, each containing 10 sublevels. In each sublevel, number of orbs is increased by one, and in each major level number of different colors is increased by number specified on selected difficulty level. For example, in Easy mode, first major level has 3 color, second has 6 colors, and third has 9 colors. In Medium mode, first major level has 5 colors, second has 10 colors, and third has 15 colors. In Hard mode, first major level has 9 colors, second has 18 colors, and third has 27 colors. Also, selected difficulty level determines the initial time for each level, time removed as punishment when selecting orb with wrong color and how many orbs will be added with each new level. The game is designed with intention that orbs are never intersecting and that colors be close to each other so that player should focus on finding the wright ones.</p><h2>Development of the Game</h2><p>The game is built using SwiftUI and RealityKit, leveraging the capabilities of Apple Vision Pro. The main components of the game are: - GameView: The main view of the game, where the RealityView is displayed. - InstructionView: A view that provides info attachment view with remaining time and chosen color. - LevelSelectView: A view that allows players to select the difficulty level. - GameCompleteOverlay: An overlay that appears when the game is completed, showing the score and allowing players to restart or go back to the main menu. - GameState: A class that manages the game state, including the current level, score, and remaining time.</p><h3>Display Immersive RealityView together with Windows within Mixed environment</h3><p>For displaying the difficulty selection screen, I use normal 2D window that is displayed right in front of the user. This is done using SwiftUI WindowGroup, which allows us to create a window that can be displayed in the mixed environment. Once the level is selected the GameView is displayed. The code for this looks like this:</p><pre><code>     <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">SwiftUI</span>.<span class="type">Scene</span> {
        <span class="type">WindowGroup</span>(id: <span class="string">"levelSelection"</span>) {
            <span class="type">LevelSelectView</span>(selectedLevel: <span class="property">$selectedLevel</span>, gameState: <span class="property">$gameState</span>)
        }.<span class="call">windowStyle</span>(.<span class="dotAccess">automatic</span>)
        
        <span class="type">ImmersiveSpace</span>(id: <span class="string">"something"</span>) {
            <span class="type">GameView</span>(gameState: <span class="property">$gameState</span>)
        }
        .<span class="call">immersionStyle</span>(selection: <span class="property">$gameImmersionStyle</span>, in: .<span class="dotAccess">mixed</span>)
    }
</code></pre><p>As you can see both WindowGroup and ImmersiveSpace have ids, so we could show them or hide them as needed. This is done using environment variables:</p><pre><code>     <span class="keyword">@Environment</span>(\.<span class="property">openImmersiveSpace</span>) <span class="keyword">var</span> openImmersiveSpace
    <span class="keyword">@Environment</span>(\.<span class="property">dismissWindow</span>) <span class="keyword">var</span> dismissWindow
</code></pre><h3>Selecting positions for orbs</h3><p>Once the difficulty level is selected, the GameState will be created and initialyied. This means that we need to create the initial positions for the orbs. This is done using a simple function that generates random positions within a specified range. The positions are stored in an array, which is then used to create the orbs in the RealityView. The code for this looks like this:</p><pre><code>         <span class="keyword">for _ in</span> <span class="number">0</span>..&lt;numberOfSpheres {
            <span class="keyword">var</span> attempts = <span class="number">0</span>
            <span class="keyword">var</span> validPosition = <span class="keyword">false
            var</span> newPosition = <span class="type">SIMD3</span>&lt;<span class="type">Float</span>&gt;(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)
            
            <span class="keyword">while</span> !validPosition &amp;&amp; attempts &lt; maxAttempts {
                <span class="comment">// Generate random position in a hemisphere in front of user
                // X: left-right spread
                // Y: up-down spread (slightly biased upward)
                // Z: forward distance with some variation</span>
                newPosition = <span class="type">SIMD3</span>&lt;<span class="type">Float</span>&gt;(
                    <span class="type">Float</span>.<span class="call">random</span>(in: -spreadRadius...spreadRadius), <span class="comment">// Left-right</span>
                    <span class="type">Float</span>.<span class="call">random</span>(in: -spreadRadius/<span class="number">2</span>...spreadRadius), <span class="comment">// Slightly up-biased</span>
                    -baseDistance + <span class="type">Float</span>.<span class="call">random</span>(in: -<span class="number">0.4</span>...<span class="number">0.4</span>) <span class="comment">// 1m forward Â± 20cm</span>
                )
                
                <span class="comment">// Check if this position is far enough from all existing spheres</span>
                validPosition = <span class="keyword">true
                for</span> existingPosition <span class="keyword">in</span> positions {
                    <span class="keyword">let</span> distance = <span class="call">length</span>(newPosition - existingPosition)
                    <span class="keyword">if</span> distance &lt; minDistance {
                        validPosition = <span class="keyword">false
                        break</span>
                    }
                }
                attempts += <span class="number">1</span>
            }
            
            positions.<span class="call">append</span>(newPosition)
        }
</code></pre><p>As you can see the positions are generated in a hemisphere in front of the user, with some random variation in the forward distance. This ensures that the orbs are not too close to each other and that they are positioned in a way that is easy for the user to interact with. All of the variables are defined in the GameState class, so they can be easily adjusted.</p><h3>Attachments and Overlays</h3><p>When the game has started, InstructionView is displayed in the front of the user, showing the remaining time and the color that needs to be collected. This is done using SwiftUI's attachment system, which allows us to create a view that is displayed in the mixed reality environment. The code for this looks like this:</p><pre><code>         <span class="type">ZStack</span> {
            <span class="type">RealityView</span> { content, attachments <span class="keyword">in</span>
                gameState.<span class="call">setupScene</span>(content: content, attachments: attachments)
            } update: { content, attachments <span class="keyword">in</span>
                gameState.<span class="call">updateScene</span>(content: content, attachments: attachments)
            } attachments: {
                <span class="type">Attachment</span>(id: <span class="string">"Instructions"</span>) {
                    <span class="type">InstructionTextView</span>(gameState: gameState)
                }
                
                <span class="type">Attachment</span>(id: <span class="string">"game-complete"</span>) {
                    <span class="type">GameCompleteOverlay</span>(gameState: gameState)
                }
            }
            .<span class="call">gesture</span>(
                <span class="type">SpatialTapGesture</span>()
                    .<span class="call">targetedToAnyEntity</span>()
                    .<span class="call">onEnded</span> { value <span class="keyword">in
                        let</span> color = gameState.<span class="call">getColorOfEntity</span>(value.<span class="property">entity</span>)
                        <span class="call">playBalloonPopSound</span>()
                        <span class="call">createExplosionEffect</span>(at: value.<span class="property">entity</span>, with: color)
                        gameState.<span class="call">handleTap</span>(on: value.<span class="property">entity</span>)
                    }
            )
        }
</code></pre><p>Where attachments will show up is set in the GameState class, in setupScene:</p><pre><code>         <span class="keyword">if let</span> instructions = attachments.<span class="call">entity</span>(for: <span class="string">"Instructions"</span>) {
            instructions.<span class="property">position</span> = <span class="type">SIMD3</span>(<span class="number">1</span>, <span class="number">1.8</span>, -<span class="number">1</span>)

            content.<span class="call">add</span>(instructions)
        }
</code></pre><p>That position is set relative to the initial anchor of the realityView.</p><h3>Anchors</h3><p>The main ancho for the game is set in the GameState class, which is used to position the RealityView in the mixed reality environment. The anchor is created using the <code>AnchorEntity</code> class, which allows us to create an anchor that can be used to position the RealityView. The code for this looks like this:</p><pre><code>         anchorEntity = <span class="type">AnchorEntity</span>(.<span class="dotAccess">head</span>, trackingMode: .<span class="dotAccess">once</span>)
        content.<span class="call">add</span>(anchorEntity)
</code></pre><p>AnchorEntity is set to track the user's head, which allows the RealityView to be positioned in front of the user. Anchor is tracked only once, which means that the game objects will not move with the user's head, but will remain in the same position relative to the user's initial position. This is important for the game, as it allows the user to interact with the orbs without having to move their head.</p><h3>Explosion Effect</h3><p>To create an explosion effect when the user taps on an orb, I used a simple particle system that is created in the RealityKit. The particle system is created using the <code>ParticleSystemComponent</code> class, which allows us to create a particle system that can be used to create the explosion effect. The code for this looks like this:</p><pre><code>     <span class="keyword">private func</span> createExplosionEffect(at entity: <span class="type">Entity</span>, with color: <span class="type">UIColor</span>) {
        
        <span class="comment">// Create custom particle explosion using multiple small cubes</span>
        <span class="keyword">let</span> particleCount = <span class="number">50</span>
        <span class="keyword">let</span> explosionEntity = <span class="type">Entity</span>()
        explosionEntity.<span class="property">position</span> = entity.<span class="property">position</span>
        
        <span class="keyword">for _ in</span> <span class="number">0</span>..&lt;particleCount {
            <span class="comment">// Create small particle cube</span>
            <span class="keyword">let</span> particleMesh = <span class="type">MeshResource</span>.<span class="call">generateBox</span>(size: <span class="number">0.01</span>) <span class="comment">// Small particles</span>
            <span class="keyword">var</span> particleMaterial = <span class="type">SimpleMaterial</span>()
            particleMaterial.<span class="property">color</span> = .<span class="keyword">init</span>(tint: color) <span class="comment">// Same color as main box</span>
            particleMaterial.<span class="property">roughness</span> = <span class="number">0.3</span>
            particleMaterial.<span class="property">metallic</span> = <span class="number">0.7</span>
            
            <span class="keyword">let</span> particle = <span class="type">ModelEntity</span>(mesh: particleMesh, materials: [particleMaterial])
            
            <span class="comment">// Random direction for explosion</span>
            <span class="keyword">let</span> randomX = <span class="type">Float</span>.<span class="call">random</span>(in: -<span class="number">1</span>...<span class="number">1</span>)
            <span class="keyword">let</span> randomY = <span class="type">Float</span>.<span class="call">random</span>(in: -<span class="number">0.5</span>...<span class="number">1</span>)
            <span class="keyword">let</span> randomZ = <span class="type">Float</span>.<span class="call">random</span>(in: -<span class="number">1</span>...<span class="number">1</span>)
            <span class="keyword">let</span> direction = <span class="call">normalize</span>(<span class="type">SIMD3</span>&lt;<span class="type">Float</span>&gt;(randomX, randomY, randomZ))
            
            <span class="comment">// Random speed</span>
            <span class="keyword">let</span> speed = <span class="type">Float</span>.<span class="call">random</span>(in: <span class="number">1.5</span>...<span class="number">3.0</span>)
            <span class="keyword">let</span> velocity = direction * speed
            
            <span class="comment">// Set initial position with slight randomness</span>
            <span class="keyword">let</span> randomOffset = <span class="type">SIMD3</span>&lt;<span class="type">Float</span>&gt;(
                <span class="type">Float</span>.<span class="call">random</span>(in: -<span class="number">0.05</span>...<span class="number">0.05</span>),
                <span class="type">Float</span>.<span class="call">random</span>(in: -<span class="number">0.05</span>...<span class="number">0.05</span>),
                <span class="type">Float</span>.<span class="call">random</span>(in: -<span class="number">0.05</span>...<span class="number">0.05</span>)
            )
            particle.<span class="property">position</span> = randomOffset
            
            explosionEntity.<span class="call">addChild</span>(particle)
            
            <span class="comment">// Animate particle movement with physics simulation</span>
            <span class="call">animateParticle</span>(particle, initialVelocity: velocity, duration: <span class="number">2.0</span>)
        }
        
        <span class="comment">// Add explosion entity to scene</span>
        entity.<span class="property">parent</span>?.<span class="call">addChild</span>(explosionEntity)
        <span class="keyword">self</span>.<span class="property">explosionEntity</span> = explosionEntity
        
        <span class="comment">// Hide the box temporarily during explosion</span>
        <span class="call">withAnimation</span>(.<span class="call">easeOut</span>(duration: <span class="number">0.2</span>)) {
            entity.<span class="property">isEnabled</span> = <span class="keyword">false</span>
        }
        
        <span class="comment">// Clean up particle system after explosion</span>
        <span class="type">DispatchQueue</span>.<span class="property">main</span>.<span class="call">asyncAfter</span>(deadline: .<span class="call">now</span>() + <span class="number">3.0</span>) {
            explosionEntity.<span class="call">removeFromParent</span>()
        }
    }
</code></pre><p>As we are dealing with orbs within the game, the particles are created to be small cubes that are randomly positioned around the orb that was tapped. The particles are animated to move in random directions with a random speed, creating an explosion effect. The explosion entity is added to the scene and is removed after a few seconds to clean up the resources. Animation for the particles is done using a simple function that applies a force to the particles, making them move in the specified direction with the specified speed. The code for this looks like this:</p><pre><code>     <span class="keyword">private func</span> animateParticle(<span class="keyword">_</span> particle: <span class="type">ModelEntity</span>, initialVelocity: <span class="type">SIMD3</span>&lt;<span class="type">Float</span>&gt;, duration: <span class="type">Float</span>) {
        <span class="keyword">let</span> gravity: <span class="type">Float</span> = -<span class="number">2.0</span>
        <span class="keyword">let</span> dampening: <span class="type">Float</span> = <span class="number">0.95</span>
        
        <span class="keyword">var</span> currentVelocity = initialVelocity
        <span class="keyword">let</span> startTime = <span class="type">CACurrentMediaTime</span>()
        
        <span class="comment">// Create a timer for physics simulation</span>
        <span class="type">Timer</span>.<span class="call">scheduledTimer</span>(withTimeInterval: <span class="number">0.016</span>, repeats: <span class="keyword">true</span>) { timer <span class="keyword">in</span> <span class="comment">// ~60 FPS</span>
            <span class="keyword">let</span> currentTime = <span class="type">CACurrentMediaTime</span>()
            <span class="keyword">let</span> elapsedTime = <span class="type">Float</span>(currentTime - startTime)
            
            <span class="keyword">if</span> elapsedTime &gt;= duration {
                timer.<span class="call">invalidate</span>()
                <span class="comment">// Fade out particle</span>
                <span class="call">withAnimation</span>(.<span class="call">easeOut</span>(duration: <span class="number">0.5</span>)) {
                    particle.<span class="property">components</span>[<span class="type">OpacityComponent</span>.<span class="keyword">self</span>] = <span class="type">OpacityComponent</span>(opacity: <span class="number">0.0</span>)
                }
                <span class="keyword">return</span>
            }
            
            <span class="comment">// Apply gravity</span>
            currentVelocity.<span class="property">y</span> += gravity * <span class="number">0.016</span> <span class="comment">// 60 FPS timestep
            
            // Apply dampening</span>
            currentVelocity *= dampening
            
            <span class="comment">// Update position</span>
            particle.<span class="property">position</span> += currentVelocity * <span class="number">0.016</span>
            
            <span class="comment">// Add rotation for visual appeal</span>
            <span class="keyword">let</span> rotationSpeed: <span class="type">Float</span> = <span class="number">2.0</span>
            <span class="keyword">let</span> currentRotation = particle.<span class="property">transform</span>.<span class="property">rotation</span>
            <span class="keyword">let</span> additionalRotation = <span class="call">simd_quatf</span>(angle: rotationSpeed * <span class="number">0.016</span>, axis: <span class="type">SIMD3</span>&lt;<span class="type">Float</span>&gt;(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>))
            particle.<span class="property">transform</span>.<span class="property">rotation</span> = currentRotation * additionalRotation
        }
    }
</code></pre><h3>Sound Effects</h3><p>There is a sound effect that is played when the user taps on an orb. The sound effect is created using the <code>AVAudioPlayer</code> class, which allows us to play a sound file when the user taps on an orb. The code for this looks like this:</p><pre><code>     <span class="keyword">private func</span> playBalloonPopSound() {
        <span class="comment">// Generate balloon pop sound programmatically using AVAudioEngine</span>
        <span class="keyword">let</span> audioEngine = <span class="type">AVAudioEngine</span>()
        <span class="keyword">let</span> playerNode = <span class="type">AVAudioPlayerNode</span>()
        <span class="keyword">let</span> audioFormat = <span class="type">AVAudioFormat</span>(standardFormatWithSampleRate: <span class="number">44100</span>, channels: <span class="number">1</span>)!
        
        <span class="comment">// Create a short burst of noise to simulate balloon pop</span>
        <span class="keyword">let</span> frameCount = <span class="type">AVAudioFrameCount</span>(<span class="number">0.2</span> * audioFormat.<span class="property">sampleRate</span>) <span class="comment">// 0.2 seconds</span>
        <span class="keyword">guard let</span> buffer = <span class="type">AVAudioPCMBuffer</span>(pcmFormat: audioFormat, frameCapacity: frameCount) <span class="keyword">else</span> { <span class="keyword">return</span> }
        buffer.<span class="property">frameLength</span> = frameCount
        
        <span class="comment">// Generate balloon pop sound - quick burst with frequency sweep</span>
        <span class="keyword">guard let</span> channelData = buffer.<span class="property">floatChannelData</span>?[<span class="number">0</span>] <span class="keyword">else</span> { <span class="keyword">return</span> }
        
        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="type">Int</span>(frameCount) {
            <span class="keyword">let</span> time = <span class="type">Float</span>(i) / <span class="type">Float</span>(audioFormat.<span class="property">sampleRate</span>)
            <span class="keyword">let</span> envelope = <span class="call">exp</span>(-time * <span class="number">15.0</span>) <span class="comment">// Quick decay envelope</span>
            <span class="keyword">let</span> frequency = <span class="number">800.0</span> * (<span class="number">1.0</span> - time * <span class="number">2.0</span>) <span class="comment">// Frequency sweep down</span>
            <span class="keyword">let</span> noise = <span class="type">Float</span>.<span class="call">random</span>(in: -<span class="number">1</span>...<span class="number">1</span>) * <span class="number">0.3</span> <span class="comment">// Add some noise</span>
            <span class="keyword">let</span> tone = <span class="call">sin</span>(<span class="number">2.0</span> * <span class="type">Float</span>.<span class="property">pi</span> * frequency * time)
            channelData[i] = (tone * <span class="number">0.7</span> + noise * <span class="number">0.3</span>) * envelope * <span class="number">0.8</span>
        }
        
        <span class="comment">// Setup and play the sound</span>
        audioEngine.<span class="call">attach</span>(playerNode)
        audioEngine.<span class="call">connect</span>(playerNode, to: audioEngine.<span class="property">mainMixerNode</span>, format: audioFormat)
        
        <span class="keyword">do</span> {
            <span class="keyword">try</span> audioEngine.<span class="call">start</span>()
            playerNode.<span class="call">scheduleBuffer</span>(buffer, at: <span class="keyword">nil</span>)
            playerNode.<span class="call">play</span>()
            
            <span class="comment">// Stop the engine after the sound finishes</span>
            <span class="type">DispatchQueue</span>.<span class="property">main</span>.<span class="call">asyncAfter</span>(deadline: .<span class="call">now</span>() + <span class="number">0.5</span>) {
                audioEngine.<span class="call">stop</span>()
            }
        } <span class="keyword">catch</span> {
            <span class="call">print</span>(<span class="string">"Failed to play balloon pop sound:</span> \(error)<span class="string">"</span>)
        }
    }
</code></pre><p>As can been seen, I am not using any pre-recorded sound files, but rather generating the sound programmatically using <code>AVAudioEngine</code>. This allows for more flexibility and control over the sound effects, making them more dynamic and engaging. Probably there is a better way to do this, but I wanted to try out how to generate sound programmatically.</p><h2>Ending the Game</h2><p>When the game is completed, the <code>GameCompleteOverlay</code> is displayed, showing the score and allowing players to restart or go back to the main menu. The overlay is created using SwiftUI's attachment system, which allows us to create a view that is displayed in the mixed reality environment. The code for this looks like this:</p><pre><code>     <span class="type">Attachment</span>(id: <span class="string">"game-complete"</span>) {
        <span class="type">GameCompleteOverlay</span>(gameState: gameState)
    }
</code></pre><p>The overlay is displayed in the front of the user, allowing them to see their score and choose whether to restart the game or go back to the main menu. The score (remaining time) is stored in UserDefaults, allowing players to see their best score for each difficulty level. The game can be restarted by simply tapping on the "Restart" button in the overlay, which will reset the game state and start a new game.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://bljubisic.github.io/posts/survey-md</guid><title>survey-md or How to Make a Survey Out of Markdown</title><description>survey-md or How to Make a Survey Out of Markdown</description><link>https://bljubisic.github.io/posts/survey-md</link><pubDate>Thu, 27 Jun 2024 19:34:00 +0200</pubDate><content:encoded><![CDATA[<h1>survey-md or How to Make a Survey Out of Markdown</h1><p>When challange appeared to either use survey framework or to build our own for a project that we were assign to, for me, it was a perfect opprtunity to try and create a survey tool that would use markdown as a underlying format. I quickly tried to find if there was anything on the market that was using the same principle and could only find this, <a href="https://github.com/Fedia/survapp">surv.app</a>. This was the only thing that resembled what I wanted to have in our survey tool. It had simple Markdown extension that allowed easy way of formulating questions and also, it also included few simple question types, like single choice, multiple choice, open ended and number questions. But it had one big disadvantage, it was a node.js app, so server side, and I wanted a framework that we could add to our already existing app. Ok, so I had a task in my hands, to rewrite server side app to a client based framework.</p><h2>Structure of the framework</h2><p>I used svelte for this as the oringinal app was built on svelte so I could re use most of the parts. The main part is of course md.js which I took with minimal changes and also SurveyNode.svelte, SurveyPrint.svelte and SurveyQuestion.svelte. I made small changes to the original files, just to make them suitable for framework usage. Also, I have added new question type, as that was needed for our project, matrix question. Let me walk you through the structure of the project.</p><p>Main action is done in md.js file, which is responsible for parsing the markdown strings and recognizing where the questions are. In addition to general parser, there are three svelte components that are responsible for markdown rendering on the screen. First two are pretty obvious ones, <code></code><code>SurveyNode.svelte</code><code></code> and <code></code><code>SurveyPrint.svelte</code><code></code> responsible for rendering the pure markdown, like paragraph or regular text with markdown syntax. The third one is the one responsible for rendering the question, <code></code><code>SurveyQuestion.svelte</code><code></code>. This is where all the question types resides. Just recently I have added matrix type of the question, which distributes the answers in a matrix type. This was done by introducing new param called matrix with format:</p><pre><code>?question_name matrix='strongly disagree, disagree, agree, strongly agree'
</code></pre><p>after which normal options follows.</p><p>Each question response is stored in context which is essential when setting up the question within your app. When ever you call</p><pre><code>&lt;<span class="type">SurveyNode</span>&gt;
</code></pre><p>you need to add parameters to it:</p><pre><code>&lt;<span class="type">SurveyNode</span> {node} bind:<span class="call">context</span> {next}&gt;
</code></pre><p>Node here is an actuall parsed markdown string, context is js object which at the initialization has an id and started_at properties, and will contain all of the answers in an object <code></code><code>{[question_name]: value}</code><code></code>. Next is an function which will be called when survey needs to move forward with the questions. It is completely empty at the start, and you need to supply the code for it.</p><h3>Question Ruleset</h3><p>As said earlier, questions are marked with markdown extension:</p><pre><code>?question_name options params=value
</code></pre><p>This question mark <code></code><code>?</code><code></code> should always be at the begining of the line imidietely followed by question name. This question name is important later. Right after this definition of question there are two options to continue. In first, when you just enter a line of text like: <code></code><code>This is a placeholder</code><code></code>, that would mean that you have created an open ended question which will result in rendered text input with 'This is a placeholder' as placeholder text. In second, if you enter something like this:</p><pre><code>- <span class="type">Option</span> <span class="number">1</span>
- <span class="type">Option</span> <span class="number">2</span>
- <span class="type">Option</span> <span class="number">3</span>
</code></pre><p>will result in single or multiple choice question and would be rendered either as radio buttons or checkboxes. Matrix questions I have already explained, so we only have left open ended questions which are the simplest one:</p><pre><code>?question_name
placeholder text
</code></pre><h3>How to use it in code</h3><p>Once you have your markdown ready, you need to structure your code to accomodate it. With what I already showed you, it is pretty easy to do. First of all, you need to set up your context which should look like this on initialization:</p><pre><code>   <span class="keyword">let</span> context = {
      uid: <span class="call">uid</span>(),
      started_at: new <span class="type">Date</span>().<span class="call">toISOString</span>().<span class="call">substring</span>(<span class="number">0</span>, <span class="number">19</span>).<span class="call">replace</span>('<span class="type">T</span>', ' ')
    };
</code></pre><p>All of your question responses would reside in Typescript object in format</p><pre><code>context['question_name'] = response
</code></pre><p>Also, you need to provide next fuction which will provide logic for progressing to new page (new question). Prev function can also be provided. In addition to this, within your questions you can have branching options, conditional skipping questions or progressing to the certain question. You don't need to do any of that with the code, all of that is done within markdown scripts. All condition statements begins with the character @ as the first character of the line, followed by javascript expression. If you want to include previous questions, you can do that by writing sometjing like this:</p><pre><code><span class="keyword">@</span> context['question_name'] === response
</code></pre><p>The question, or page will be rendered only if the condition is met. If not, it will be skipped. On one page you can have multiple questions.</p><p>After this you need to add your page, as string, and parse it using md.js. The result of that parsing is fed to the SurveyNode in code that looks something like this:</p><pre><code>&lt;div <span class="keyword">class</span>=<span class="string">"viewport typo"</span>&gt;
{#each data.<span class="property">post</span>.<span class="property">content</span> <span class="keyword">as</span> page, i}
  {<span class="preprocessing">#if i === pageIndex}</span>
    &lt;div
      <span class="keyword">class</span>=<span class="string">"view"</span>&gt;
      &lt;div <span class="keyword">class</span>=<span class="string">"view-body"</span>&gt;
        {#each page.<span class="property">children</span> <span class="keyword">as</span> node}
          &lt;<span class="type">SurveyNode</span> {node} bind:<span class="call">context</span> {next} /&gt;
        {/each}
      &lt;/div&gt;
    &lt;/div&gt;
  {/<span class="keyword">if</span>}
{/each}
&lt;/div&gt;
</code></pre><p>As you can see, each question is viewed as a node and will be separately parsed and rendered on the screen. SurveyNode is responsible for this. You may ask, but where is SurveyQuestion now? Well, SurveyQuestion is called by SurveyNode any time that question is recognized within the markdown string. Same parameters will be passed to it, context and next function.</p><h3>Future of the project</h3><p>So far, I see this project as a open sorced project that shall remain so. In future I could see adding React or Angular support to it, but most interesting for me is moving this kind of rendering of questions to iOS and implementing all of this in Swift. Stay tuned...</p>]]></content:encoded></item><item><guid isPermaLink="true">https://bljubisic.github.io/posts/Ionic%20React%20and%20Auth0%20%E2%80%94%20Config</guid><title>Ionic React and Auth0 â Config</title><description>Ionic React and Auth0 â Config.</description><link>https://bljubisic.github.io/posts/Ionic%20React%20and%20Auth0%20%E2%80%94%20Config</link><pubDate>Sat, 18 Mar 2023 19:04:00 +0100</pubDate><content:encoded><![CDATA[<h1>Ionic React and Auth0 â Config</h1><h3>What is Auth0</h3><p>I came across Auth0 in my current position as Frontend developer as a cool way to have all available social login possibilities as well as old fashioned email/password login, and all of that without anything on your FE or BE side. These possibilities are great if you are just exploring what your customers would like to see as a Login options.Integration with existing FE and BE is seamless and they provide you with good documentation for all major platforms. Why then I am writing this then? Well, we had very exotic setup on our side, at least on Frontend side. We are using combination of Ionic and React and all of that using capacitor. But more on that later.</p><h3>Client Setup</h3><p>As said we are using Ionic + React and all that without cordova and with capacitor instead. This Capacitor thing does not pose a problem because you can still use Cordova plugins within it. This thing is that documentation for Ionic on Auth0 is available only for Angular and this created a bit of a issue within our team. But, after careful investigation (try and error phase) we concluded that you can use all of the Angular plugins with some of the React tweaks.</p><h3>Auth0 Configuration</h3><p>When you signup for Auth0 a new application will be created for you, or you can do the same at any time. Once you do that you will get all application details for your new application. Those details we will use later when we are setting up our login setup. For now make sure you get two things:</p><ul><li>Domain<ul><li>Client ID</li></ul></li></ul><p>First thing you need to configure on your end is callback URL. This will have following format:</p><pre><code># replace <span class="type">YOUR_PACKAGE_ID</span> with your app package <span class="type">ID 
YOUR_PACKAGE_ID</span>://<span class="type">YOUR_DOMAIN</span>/cordova/<span class="type">YOUR_PACKAGE_ID</span>/callback
</code></pre><p>Domain you have from your application data and package id is your package id :).</p><p>Now, the next step is always configuring CORS on Auth0, but you can see this already in their documentation for Angular for example. Add at least localhost to your CORS setting within Auth0:</p><pre><code>http://localhost, ionic://localhost, http://localhost:<span class="number">8100</span>
</code></pre><h3>React Implementation</h3><p>After this youâll need to add necessary libraries. We are using npm so the command would look like this:</p><pre><code>npm install auth0-js <span class="keyword">@auth0</span>/cordova <span class="keyword">@ionic</span>/storage --save
</code></pre><p>But I guess that installing using yarn would not be that much different. Next thing to add are cordova plugins, and this would require a bit of tweaking because instead of Cordova we are using Capacitor</p><pre><code>npm install --save <span class="keyword">@ionic</span>-native/safari-view-controller
npm install --save cordova-plugin-customurlscheme
</code></pre><p>This <em>cordova-plugin-customurlscheme</em> is responsible for adding custom url scheme in your project but as we are not using Cordova we have to do by ourselves. On iOS you need to go to Xcode and open you project in there, and add in info.plist something like this:</p><pre><code>&lt;dict&gt;
  &lt;key&gt;<span class="type">CFBundleURLSchemes</span>&lt;/key&gt;
  &lt;array&gt;
    &lt;string&gt;<span class="type">YOUR_PACKAGE_ID</span>&lt;/string&gt;
  &lt;/array&gt;
&lt;/dict&gt;
</code></pre><p>Also, you need to enable the app ability to be opened by following URL in AppDelegate.swift:</p><pre><code><span class="keyword">func</span> application(<span class="keyword">_</span> application: <span class="type">UIApplication</span>, continue userActivity: <span class="type">NSUserActivity</span>, restorationHandler: <span class="keyword">@escaping</span> ([<span class="type">UIUserActivityRestoring</span>]?) -&gt; <span class="type">Void</span>) -&gt; <span class="type">Bool</span> {
  <span class="comment">// Called when the app was launched with an activity, including      Universal Links.
  // Feel free to add additional processing here, but if you want the App API to support
  // tracking app url opens, make sure to keep this call</span>
  <span class="keyword">return</span> <span class="type">CAPBridge</span>.<span class="call">handleContinueActivity</span>(userActivity, restorationHandler)
}
</code></pre><p>So, as you can see, not that much work. I am dealing only with iOS here, but Android is not my thing anyway. Now we are getting to the part where we have to create our code in Ionic itself. First of all we need to create a React component that will handle the URL redirects. We did this by adding AppUrlListener:</p><pre><code><span class="keyword">import</span> React, { useEffect } from 'react';
<span class="keyword">import</span> { <span class="type">Plugins</span> } from '<span class="keyword">@capacitor</span>/core';
<span class="call">const</span> { <span class="type">App</span>: <span class="type">CapApp</span> } = <span class="type">Plugins</span>;
<span class="comment">// eslint-disable-next-line @typescript-eslint/no-var-requires</span>
const <span class="type">Auth0Cordova</span> = <span class="call">require</span>('<span class="keyword">@auth0</span>/cordova');

const <span class="type">AppUrlListener</span>: <span class="type">React</span>.<span class="type">FC</span>&lt;any&gt; = () =&gt; {
  <span class="call">useEffect</span>(() =&gt; {
    <span class="type">CapApp</span>.<span class="call">addListener</span>('appUrlOpen', (data: any) =&gt; {
      <span class="type">Auth0Cordova</span>.<span class="call">onRedirectUri</span>(data.<span class="property">url</span>);
    });
  });
  <span class="keyword">return</span> null;
};
</code></pre><p>This will enable you app to continue the login process once your callback URL is called by Auth0. AppUrlListener must be invoked in App.tsx as a standalone tag. After this you need to add Auth0 configuration variables:</p><pre><code>export const <span class="type">AUTH_CONFIG</span> = {
  <span class="comment">// Needed for Auth0 (capitalization: ID):</span>
  clientID: '<span class="type">YOUR_CLIENT_ID</span>',
  <span class="comment">// Needed for Auth0Cordova (capitalization: Id):</span>
  clientId: '<span class="type">YOUR_CLIENT_ID</span>',
  domain: '<span class="type">YOUR_DOMAIN</span>',
  packageIdentifier: '<span class="type">YOUR_PACKAGE_ID</span>' <span class="comment">// config.xml widget ID, e.g., com.auth0.ionic</span>
};
</code></pre><p>Now you are ready to add your Login service, or component. We are using this React way, so once the page is loaded it will directly redirect to Auth0 Login page and start login process. This way customers have one less item to click and the Login process is seamless.</p><pre><code>const <span class="type">Auth0Cordova</span> = <span class="call">require</span>('<span class="keyword">@auth0</span>/cordova');

const <span class="type">Client</span> = new <span class="type">Auth0Cordova</span>(<span class="type">CONFIG</span>.<span class="type">AUTH_CONFIG</span>);

export const <span class="type">SignIn</span>: <span class="type">FC</span>&lt;<span class="type">StepInterface</span>&gt; = ({ currentStep, setNextStep }) =&gt; {
  const dispatch = <span class="call">useDispatch</span>();
  
  <span class="call">useEffect</span>(() =&gt; {
    const handleExchangeResponse = (res: any, rToken: string) =&gt; {
      <span class="comment">// YOUR IMPLEMENTATION OF BACKEND</span>
    };

    const loginWithAuth0 = () =&gt; {
      const options = {
        scope: 'openid profile offline_access',
      };

      <span class="type">Client</span>.<span class="call">authorize</span>(options, (err: any, authResult: any) =&gt; {
        <span class="keyword">if</span> (err) {
          <span class="comment">// todo show error</span>
          <span class="keyword">return</span> <span class="call">handleSocialLoginError</span>('auth0', err);
        }

        const body = {
          <span class="comment">// BACKEND CONFIGURATION</span>
        };

        <span class="comment">// BACKEND CALL</span>
      });
    };

    <span class="call">loginWithAuth0</span>();
  }, [dispatch]);
  
    <span class="keyword">return</span> (
    &lt;<span class="type">IonPage</span>&gt;
      {showError ? (
        &lt;<span class="type">ErrorMessage</span>&gt;<span class="type">Something</span> went wrong&lt;/<span class="type">ErrorMessage</span>&gt;
      ) : (
        &lt;<span class="type">IonLoading</span> isOpen={<span class="keyword">true</span>} message={'<span class="type">Un Momento</span>...'} /&gt;
      )}
    &lt;/<span class="type">IonPage</span>&gt;
  );
};
</code></pre><p>I have omitted some of the implementation specifics but even without this it is clear how is this used in React component. We are using useEffect to run this when the page is loaded. And this is all that is to have Auth0 running on React. As said it is rather easy to have it implemented this way. The only thing missing is sign out but this is even easier:</p><pre><code><span class="keyword">import</span> { <span class="type">SafariViewController</span> } from '<span class="keyword">@ionic</span>-native/safari-view-controller';

export const signUserOut = (): <span class="type">AppThunk</span> =&gt; (dispatch) =&gt; {
  <span class="type">SafariViewController</span>.<span class="call">isAvailable</span>()
    .<span class="call">then</span>((available: boolean) =&gt; {
      const domain = <span class="type">CONFIG</span>.<span class="type">AUTH_CONFIG</span>.<span class="property">domain</span>;
      const clientId = <span class="type">CONFIG</span>.<span class="type">AUTH_CONFIG</span>.<span class="property">clientId</span>;
      const pkgId = <span class="type">CONFIG</span>.<span class="type">AUTH_CONFIG</span>.<span class="property">packageIdentifier</span>;
      const url = `https://${domain}/v2/logout?client_id=${clientId}&amp;returnTo=${pkgId}://${domain}/cordova/${pkgId}/callback`;
      <span class="keyword">if</span> (available) {
        <span class="type">SafariViewController</span>.<span class="call">show</span>({ url }).<span class="call">subscribe</span>((result: any) =&gt; {
          <span class="keyword">if</span> (result.<span class="property">event</span> === 'loaded') {
            <span class="type">SafariViewController</span>.<span class="call">hide</span>();
            <span class="call">const</span> { signOut } = signinSlice.<span class="property">actions</span>;
            localStorage.<span class="call">removeItem</span>('token');
            localStorage.<span class="call">removeItem</span>('user');
            localStorage.<span class="call">removeItem</span>('rToken');
            client.<span class="call">clearStore</span>();
            <span class="call">dispatch</span>(<span class="call">signOut</span>());
          }
        });
      }
    })
    .<span class="call">catch</span>((err) =&gt; {
      console.<span class="call">log</span>(err);
    });
};
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://bljubisic.github.io/posts/QuickToDo%20CoreData%20+%20Rx%20+%20MVVM%20(Part%202)</guid><title>QuickToDo CoreData + Rx + MVVM (Part 2)</title><description>QuickToDo RxSwift and MVVM.</description><link>https://bljubisic.github.io/posts/QuickToDo%20CoreData%20+%20Rx%20+%20MVVM%20(Part%202)</link><pubDate>Sat, 18 Mar 2023 15:25:00 +0100</pubDate><content:encoded><![CDATA[<h1>QuickToDo CoreData + Rx + MVVM (Part 2)</h1><h2>Rx + MVVM</h2><p>As written in first part, general architecture for this sample app is MVVM with RxSwift in Model and ViewModel layer. Communication between View and ViewModel is done in more traditional way, but that will be explained later. This way app is build in more simple way and is easily maintained. View section is kept at its minimal, and does not contain any logic to it. All logic stuff is in ViewModel and Model layers. Model layer is seen as a compact layer from ViewModel, and it only has one entry point to it. All specific modules, like Core Data or Cloud Kit are kept invisible for ViewModel or View. Internal communication within Model is also built around Rx. Because of that, in Storage Protocol you can see that itâs output is this:</p><pre><code><span class="keyword">protocol</span> QuickToDoStorageOutputs {
    <span class="keyword">var</span> items: <span class="type">Observable</span>&lt;<span class="type">Item</span>&gt; { <span class="keyword">get</span> }
}
</code></pre><p>That observable is implemented as PublishSubject in CoreDataModel.swift.</p><pre><code><span class="keyword">private var</span> itemsPrivate: <span class="type">PublishSubject</span>&lt;<span class="type">Item</span>&gt;

<span class="keyword">var</span> items: <span class="type">Observable</span>&lt;<span class="type">Item</span>&gt; {
    <span class="keyword">return</span> itemsPrivate.<span class="call">subscribeOn</span>(<span class="type">ConcurrentDispatchQueueScheduler</span>(qos: .<span class="dotAccess">background</span>))
}
</code></pre><p>As you can see this observable will be subscribed on background thread. Within getItems() function, found Items are pumped into this observable:</p><pre><code><span class="keyword">for</span> itemMO <span class="keyword">in</span> fetchedItems {
    <span class="keyword">let</span> tmpItem: <span class="type">Item</span> = <span class="type">Item</span>(id: <span class="type">UUID</span>(uuidString: itemMO.<span class="property">id</span>)!,
                             name: itemMO.<span class="property">word</span>,
                             count: itemMO.<span class="property">count</span>,
                             uploadedToICloud: itemMO.<span class="property">uploadedToICloud</span>,
                             done: itemMO.<span class="property">completed</span>,
                             shown: itemMO.<span class="property">used</span>,
                             createdAt: itemMO.<span class="property">lastused</span>,
                             lastUsedAt: itemMO.<span class="property">lastused</span>)
    itemsPrivate.<span class="call">onNext</span>(tmpItem)
}
</code></pre><p>ViewModel is effectively subscribed to this observable on Main thread, and with each new Item received it will add that item as new entry in Items array. This array is actually consumed by View and it is displayed as a TableView:</p><pre><code><span class="keyword">self</span>.<span class="property">model</span>.<span class="property">outputs</span>.<span class="property">items</span>
    .<span class="call">observe</span>(on: <span class="type">MainScheduler</span>.<span class="property">instance</span>)
    .<span class="call">filter</span>({ (item) -&gt; <span class="type">Bool</span> <span class="keyword">in
        return</span> item.<span class="property">name</span> != <span class="string">""</span>
    })
    .<span class="call">subscribe</span>(onNext: { (newItem) <span class="keyword">in
        if</span> !<span class="keyword">self</span>.<span class="property">itemsArray</span>.<span class="call">contains</span>(where: { (item) -&gt; <span class="type">Bool</span> <span class="keyword">in</span>
            item.<span class="property">id</span> == newItem.<span class="property">id</span>
        }) {
            <span class="keyword">self</span>.<span class="property">itemsArray</span>.<span class="call">append</span>(newItem)
            <span class="type">DispatchQueue</span>.<span class="property">main</span>.<span class="call">async</span> {
                <span class="call">completionBlock</span>()
            }
            
        } <span class="keyword">else</span> {
            <span class="keyword">if let</span> index = <span class="keyword">self</span>.<span class="property">itemsArray</span>.<span class="call">firstIndex</span>(where: { (item) -&gt; <span class="type">Bool</span> <span class="keyword">in</span>
                item.<span class="property">id</span> == newItem.<span class="property">id</span>
            }) {
                <span class="keyword">let</span> item = <span class="keyword">self</span>.<span class="property">itemsArray</span>[index]
                <span class="keyword">if</span> (item.<span class="property">lastUsedAt</span> &lt; newItem.<span class="property">lastUsedAt</span>) {
                    <span class="keyword">self</span>.<span class="property">itemsArray</span>[index] = newItem
                }
            }
        }
    }, onError: { (<span class="type">Error</span>) <span class="keyword">in</span>
        <span class="call">print</span>(<span class="type">Error</span>)
    }, onDisposed:  {
    }).<span class="call">disposed</span>(by: disposeBag)
</code></pre><p>CompletionBlock in this case is nothing more than TableView reload so that new items can be seen on View. With all of this we now have perfectly workable example of to do list app, but I wanted to add a little complication to it, so it would not be that simple. I thought that it would be nice to have simple hints when you try to enter new items, maybe from the database of already used items. We already have in place what we need in the database schema, so now we just need to implement this. We will start from Model, getHints method returns <code>Observable&lt;String&gt;</code>:</p><pre><code><span class="keyword">return</span> <span class="type">Observable</span>.<span class="call">create</span>({ (observer) -&gt; <span class="type">Disposable</span> <span class="keyword">in
    self</span>.<span class="property">coreData</span>.<span class="property">inputs</span>.<span class="call">getHints</span>(for: itemName) { (firstItem, secondItem) <span class="keyword">in</span>
        observer.<span class="call">onNext</span>(firstItem.<span class="property">name</span>)
        observer.<span class="call">onNext</span>(secondItem.<span class="property">name</span>)
        observer.<span class="call">onCompleted</span>()
    }
    <span class="keyword">return</span> <span class="type">Disposables</span>.<span class="call">create</span>()
})
.<span class="call">subscribe</span>(on: <span class="type">ConcurrentDispatchQueueScheduler</span>(qos: .<span class="dotAccess">background</span>))
.<span class="call">observe</span>(on: <span class="type">MainScheduler</span>.<span class="property">instance</span>)
</code></pre><p>This Observable is subscribed on background thread but observed on main thread. That means that it will try to run in background thread (which is a rule when dealing with CoreData or network access, eg. CloudKit), but it will return values on main thread which is needed as we will display those values on UI.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://bljubisic.github.io/posts/QuickToDo%20CoreData%20+%20Rx%20+%20MVVM</guid><title>QuickToDo CoreData + Rx + MVVM</title><description>QuickToDo Core Data explained.</description><link>https://bljubisic.github.io/posts/QuickToDo%20CoreData%20+%20Rx%20+%20MVVM</link><pubDate>Sat, 18 Mar 2023 15:20:00 +0100</pubDate><content:encoded><![CDATA[<h1>QuickToDo CoreData + Rx + MVVM</h1><h2>Part 1: Core Data</h2><p>I have already started writing about new version of the QuickToDo app but, with all things happening in private life, moving to Germany, starting new job and trying to accommodate all of that in the same time, I had not much time left to work on this. Fortunately I have created substantial part of the app already. I will write more about those parts of the application: MVVM and RxSwift integration, including CoreData modifications.</p><p>First of all I have decided to use RxSwift implementation of frp paradigm. With that came the decision to use MVVM as way to organise the code. I will try to explain in details how I use those two paradigms together. But, before all of that I would like to write more about CoreData modifications.</p><p>First of all, there is an understanding that Rx should be used in Model section of app and as such, it is not directly visible in View section. Connection points between Model and View is ModelView which is subscribed to signals coming from Model and translate those to regular output variables consumable by View. Also, there is an understanding that View will never directly converse with Model, the connection should only be through ViewModel.</p><img src="https://bljubisic.github.io/Images/QuickToDoScheme.png" alt="image scheme"/><p>This is very simplified architecture sketch for the app. I will first try to describe the data model for the app. Whole source code can be found here.</p><pre><code><span class="keyword">public struct</span> Item: <span class="type">Codable</span>{
    <span class="keyword">let</span> name: <span class="type">String</span>
    <span class="keyword">let</span> count: <span class="type">Int</span>
    <span class="keyword">let</span> uploadedToICloud: <span class="type">Bool</span>
    <span class="keyword">let</span> done: <span class="type">Bool</span>
    <span class="keyword">let</span> shown: <span class="type">Bool</span>
    <span class="keyword">let</span> createdAt: <span class="type">Date</span>
}

<span class="keyword">extension</span> <span class="type">Item</span> {
    <span class="keyword">init</span>() {
        name = <span class="string">""</span>
        count = <span class="number">0</span>
        uploadedToICloud = <span class="keyword">false</span>
        done = <span class="keyword">false</span>
        shown = <span class="keyword">false</span>
        createdAt = <span class="type">Date</span>()
    }
}
</code></pre><p>Item object</p><p>As you can see here, Item is the focal point for QuickToDo app. Extension is added just to keep both initialisers for struct, one with variables and one empty, which will be used to create Item with default values. All properties of the structure are read only, and this was done on purpose, because I am using lenses to do updates to Item, as displayed here:</p><pre><code><span class="keyword">struct</span> Lens&lt;Whole, Part&gt; {
    <span class="keyword">let</span> get: (<span class="type">Whole</span>) -&gt; <span class="type">Part</span>
    <span class="keyword">let</span> set: (<span class="type">Part</span>, <span class="type">Whole</span>) -&gt; <span class="type">Whole</span>
}
</code></pre><p>Lens definition</p><p>I would like to go into more details of the Core Data part. The most important parts are hidden in ManagedObjectTypeProtocol.swift file within CoreData folder. Here is the code explained:</p><pre><code><span class="keyword">public protocol</span> ManagedObjectType: <span class="keyword">class</span> {
    <span class="keyword">static var</span> entityName: <span class="type">String</span> { <span class="keyword">get</span> }
    <span class="keyword">static var</span> defaultSortDescriptors: [<span class="type">NSSortDescriptor</span>] { <span class="keyword">get</span> }
}

<span class="keyword">extension</span> <span class="type">ManagedObjectType</span> {
    <span class="keyword">public static var</span> defaultSortDescriptors: [<span class="type">NSSortDescriptor</span>] {
        <span class="keyword">return</span> []
    }
    
    <span class="keyword">public static var</span> sortedFetchRequest: <span class="type">NSFetchRequest</span>&lt;<span class="type">NSFetchRequestResult</span>&gt; {
        <span class="keyword">let</span> request = <span class="type">NSFetchRequest</span>&lt;<span class="type">NSFetchRequestResult</span>&gt;(entityName: entityName)
        request.<span class="property">sortDescriptors</span> = defaultSortDescriptors
        <span class="keyword">return</span> request
    }
}

<span class="keyword">extension</span> <span class="type">ManagedObjectType</span> <span class="keyword">where</span> <span class="type">Self</span>: <span class="type">ManagedObject</span> {
    <span class="keyword">public static func</span> findOrCreateInContext(moc: <span class="type">NSManagedObjectContext</span>, matchingPredicate predicate:<span class="type">NSPredicate</span>, configure: (<span class="type">Self</span>) -&gt; ()) -&gt; <span class="type">Self</span> {
        <span class="keyword">guard let</span> obj = <span class="call">findOrFetchInContext</span>(moc: moc, matchingPredicate: predicate) <span class="keyword">else</span> {
            <span class="keyword">let</span> newObject: <span class="type">Self</span> = moc.<span class="call">insertObject</span>()
            <span class="call">configure</span>(newObject)
            <span class="keyword">return</span> newObject
        }
        <span class="keyword">return</span> obj
    }
    
    <span class="keyword">public static func</span> findOrFetchInContext(moc: <span class="type">NSManagedObjectContext</span>, matchingPredicate predicate: <span class="type">NSPredicate</span>) -&gt; <span class="type">Self</span>? {
        <span class="keyword">guard let</span> obj = <span class="call">materializedObjectInContext</span>(moc: moc, matchingPredicate: predicate)
            <span class="keyword">else</span> {
                <span class="keyword">return</span> <span class="call">fetchInContext</span>(context: moc) { request <span class="keyword">in</span>
                    request.<span class="property">predicate</span> = predicate
                    request.<span class="property">returnsObjectsAsFaults</span> = <span class="keyword">false</span>
                    request.<span class="property">fetchLimit</span> = <span class="number">1</span>
                    }.first
        }
        <span class="keyword">return</span> obj
    }
}

<span class="keyword">extension</span> <span class="type">ManagedObjectType</span> <span class="keyword">where</span> <span class="type">Self</span>: <span class="type">ManagedObject</span> {
    <span class="keyword">public static func</span> materializedObjectInContext(moc: <span class="type">NSManagedObjectContext</span>, matchingPredicate predicate:<span class="type">NSPredicate</span>) -&gt; <span class="type">Self</span>? {
        <span class="keyword">for</span> obj <span class="keyword">in</span> moc.<span class="property">registeredObjects</span> <span class="keyword">where</span> !obj.<span class="property">isFault</span> {
            <span class="keyword">guard let</span> res = obj <span class="keyword">as</span>? <span class="type">Self</span>, predicate.<span class="call">evaluate</span>(with: res)
                <span class="keyword">else</span> { <span class="keyword">continue</span> }
            <span class="keyword">return</span> res
        }
        <span class="keyword">return nil</span>
    }
}

<span class="keyword">extension</span> <span class="type">ManagedObjectType</span> <span class="keyword">where</span> <span class="type">Self</span>: <span class="type">ManagedObject</span> {
    <span class="keyword">public static func</span> fetchInContext(context: <span class="type">NSManagedObjectContext</span>, configurationBlock: (<span class="type">NSFetchRequest</span>&lt;<span class="type">NSFetchRequestResult</span>&gt;) -&gt; () = {<span class="keyword">_ in</span> }) -&gt; [<span class="type">Self</span>] {
        <span class="keyword">let</span> request = <span class="type">NSFetchRequest</span>&lt;<span class="type">NSFetchRequestResult</span>&gt;(entityName: <span class="type">Self</span>.<span class="property">entityName</span>)
        <span class="call">configurationBlock</span>(request)
        <span class="keyword">guard let</span> result = <span class="keyword">try</span>! context.<span class="call">fetch</span>(request) <span class="keyword">as</span>? [<span class="type">Self</span>]
            <span class="keyword">else</span> {
                <span class="call">fatalError</span>(<span class="string">"Fetched object have wrong type"</span>)
        }
        <span class="keyword">return</span> result
    }
}
</code></pre><p>Managed Object Type Protocol</p><p>Now, this ManagedObjectType is actually used when defining real Item Managed Object:</p><pre><code><span class="keyword">public final class</span> ItemMO: <span class="type">ManagedObject</span> {
    
    <span class="keyword">@NSManaged public private(set) var</span> completed: <span class="type">Bool</span>
    <span class="keyword">@NSManaged public private(set) var</span> count: <span class="type">Int</span>
    <span class="keyword">@NSManaged public private(set) var</span> lastused: <span class="type">Date</span>
    <span class="keyword">@NSManaged public private(set) var</span> used: <span class="type">Bool</span>
    <span class="keyword">@NSManaged public private(set) var</span> word: <span class="type">String</span>
    <span class="keyword">@NSManaged public private(set) var</span> uploadedToICloud: <span class="type">Bool</span>
    
    <span class="keyword">public static func</span> insertIntoContext(moc: <span class="type">NSManagedObjectContext</span>, item: <span class="type">Item</span>) -&gt; <span class="type">ItemMO</span> {
        <span class="keyword">let</span> localItemMO: <span class="type">ItemMO</span> = moc.<span class="call">insertObject</span>()
        localItemMO.<span class="property">completed</span> = item.<span class="property">done</span>
        localItemMO.<span class="property">count</span> = item.<span class="property">count</span>
        localItemMO.<span class="property">lastused</span> = <span class="type">Date</span>()
        localItemMO.<span class="property">used</span> = item.<span class="property">shown</span>
        localItemMO.<span class="property">word</span> = item.<span class="property">name</span>
        localItemMO.<span class="property">uploadedToICloud</span> = item.<span class="property">uploadedToICloud</span>
        <span class="keyword">_</span> = moc.<span class="call">saveOrRollback</span>()
        <span class="keyword">return</span> localItemMO
    }
    
    <span class="keyword">public static func</span> updateIntoContext(moc: <span class="type">NSManagedObjectContext</span>, item: <span class="type">Item</span>) -&gt; (<span class="type">ItemMO</span>?, <span class="type">Bool</span>) {
        <span class="keyword">let</span> predicate: <span class="type">NSPredicate</span> = <span class="type">NSPredicate</span>(format: <span class="string">"%K == %@"</span>, <span class="string">"word"</span>, item.<span class="property">name</span>)
        <span class="keyword">let</span> oldItemMOWrapped: <span class="type">ItemMO</span>? = <span class="type">ItemMO</span>.<span class="call">findOrFetchInContext</span>(moc: moc, matchingPredicate: predicate)
        <span class="keyword">guard let</span> oldItemMO = oldItemMOWrapped <span class="keyword">else</span> {
            <span class="keyword">return</span> (<span class="keyword">nil</span>, <span class="keyword">false</span>)
        }
        oldItemMO.<span class="property">completed</span> = item.<span class="property">done</span>
        oldItemMO.<span class="property">count</span> = item.<span class="property">count</span>
        oldItemMO.<span class="property">lastused</span> = <span class="type">Date</span>()
        oldItemMO.<span class="property">used</span> = item.<span class="property">shown</span>
        oldItemMO.<span class="property">word</span> = item.<span class="property">name</span>
        oldItemMO.<span class="property">uploadedToICloud</span> = item.<span class="property">uploadedToICloud</span>
        <span class="keyword">let</span> returnValue = moc.<span class="call">saveOrRollback</span>()
        <span class="call">return</span>(oldItemMO, returnValue)
    }
}

<span class="keyword">extension</span> <span class="type">ItemMO</span>: <span class="type">ManagedObjectType</span> {
    <span class="keyword">public static var</span> entityName: <span class="type">String</span> {
        <span class="keyword">return</span> <span class="string">"Item"</span>
    }
    
    <span class="keyword">public static var</span> defaultSortDescriptors: [<span class="type">NSSortDescriptor</span>] {
        <span class="keyword">return</span> [<span class="type">NSSortDescriptor</span>(key: <span class="string">"lastused"</span>, ascending: <span class="keyword">false</span>)]
    }
}
</code></pre><p>You can see that by using ManagedObjectType, you now have fetchInContext and findOrCreateInContext methods. Right now they are simple, but this is the place where you can add caching and all other fancy stuff from Core Data. Using the CoreData like this, you are using typed Entity and not generic Entity created using the String denominator. This change would prompt compiler errors if used incorrectly. Otherwise, if for example entity name is misspelled compiler would not register that error, but it will be present in run time. With all of these changes, it is very straight forward to write CoreDataModel.swift which can be seen in GitHub.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://bljubisic.github.io/posts/first-post</guid><title>My first post</title><description>A description of my first post.</description><link>https://bljubisic.github.io/posts/first-post</link><pubDate>Sat, 28 Jan 2023 18:36:00 +0100</pubDate><content:encoded><![CDATA[<h1>My first post</h1><p>My first post's text.</p>]]></content:encoded></item></channel></rss>